
plugins {
    id 'java'
    id 'org.springframework.boot' version '2.5.6'
}

group 'org.example'
version '1.0-SNAPSHOT'

java.sourceCompatibility = JavaVersion.VERSION_1_8;

repositories {
    mavenLocal()
    mavenCentral()
}

sourceSets.main.java.srcDirs = ['src/main/java']

dependencies {
    implementation "org.springframework.boot:spring-boot-starter-web:2.5.6"

    /*
    compileOnly - compile stage (servlet-api) (equivalent of maven 'provided')
    runtimeOnly - runtime stage (hibernate, postgres) (equivalent of runtime maven scope)
    implementation - accessible both in compile and runtime (equivalent of maven default scope)

    Deprecated:
    compile, runtime

    What will be accessible for tests:
    runtimeOnly - will be accessible in tests runtime
    implementation - accessible in tests implementation (compile + runtime)
    compileOnly - not accessible from tests

    Testing:
    testCompileOnly - test compile stage (not in project compile)
    testRuntimeOnly - test runtime stage (not in project runtime)
    testImplementation - compile + runtime (equivalent of maven 'test')

    Deprecated:
    testCompile, testRuntime

    Annotation processing (no analogs in maven):
    annotationProcessor - project annotation processing (except test)
    testAnnotationProcessor - annotation processing in tests

    For library modules:
    api - making dependency available when you writing a library, or importing module
    compileOnlyApi - same as api, not found differences
    */

    annotationProcessor "org.projectlombok:lombok:1.18.16"
//    compileOnly 'org.projectlombok:lombok:1.18.16'
//    testCompileOnly 'org.projectlombok:lombok:1.18.16'
//    testAnnotationProcessor 'org.projectlombok:lombok:1.18.16'

    implementation gradleApi()
}

configurations {
    compileOnly.extendsFrom annotationProcessor
    testCompileOnly.extendsFrom annotaionProcessor
    testAnnotationProcessor.extendsFrom annotaionProcessor
}

/*
Task - work unit

Every task in gradle is an object, it can be configured,
you can inherit your task from it and add something to it by yourself.

In task you can add any java/groovy code - it is a power and a weakness,
                                           because you can do anything.

: gradle tasks - print avaliable tasks
: gradle clean - remove build package
: gradle build - build project
: gradle build -x test - build project and skip 'test' task
: gradlew.bat build --dry-run - run build task and show tasks running order
*/

// Create task
task helloViewer {
    doFirst {
        println 'Hello, ' + nameProperty + '!'
    }
}

/*
dependOn check
build.dependsOn helloWorld
*/

//import com.panyukovnn.GreetingTask
//
//task greetingTask(type: GreetingTask) {
//    group "custom group"
//    greetingName "Viewer"
//}

//configurations {
//    all*.exclude module: 'spring-boot-starter-logging' // fix logging issue
//}
